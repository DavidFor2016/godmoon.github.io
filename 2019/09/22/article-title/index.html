<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="iOS启动优化与监控在开篇前，我们来模拟一个场景：假设你在买票结账的时候，掏出手机打开A支付App准备扫码支付，结果半天进不去，后面排队的人给你压力本身够大吧，然后，你又打开B支付App，秒进，支付完成后，试想一下，以后再次支付时，你会选择哪一个App呢。 不难想象，在功能与服务都类似的情况下，一款App的启动速度，不单单是用户体验的事情，往往还决定了它能否获取更多的用户。这就像第一次相亲见面，第">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2019/09/22/article-title/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="iOS启动优化与监控在开篇前，我们来模拟一个场景：假设你在买票结账的时候，掏出手机打开A支付App准备扫码支付，结果半天进不去，后面排队的人给你压力本身够大吧，然后，你又打开B支付App，秒进，支付完成后，试想一下，以后再次支付时，你会选择哪一个App呢。 不难想象，在功能与服务都类似的情况下，一款App的启动速度，不单单是用户体验的事情，往往还决定了它能否获取更多的用户。这就像第一次相亲见面，第">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/2019/09/22/article-title/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/article-title/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg">
<meta property="og:image" content="http://yoursite.com/2019/09/22/article-title/%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BApre-main%E7%9A%84%E6%80%BB%E6%97%B6%E9%97%B4.jpg">
<meta property="og:image" content="http://yoursite.com/2019/09/22/article-title/%E5%8A%A8%E6%80%81%E5%BA%93%E8%AE%BE%E7%BD%AE.jpg">
<meta property="og:image" content="http://yoursite.com/2019/09/22/article-title/%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%8A%A8%E6%80%81%E5%BA%93.jpg">
<meta property="og:updated_time" content="2019-09-22T07:43:27.507Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="iOS启动优化与监控在开篇前，我们来模拟一个场景：假设你在买票结账的时候，掏出手机打开A支付App准备扫码支付，结果半天进不去，后面排队的人给你压力本身够大吧，然后，你又打开B支付App，秒进，支付完成后，试想一下，以后再次支付时，你会选择哪一个App呢。 不难想象，在功能与服务都类似的情况下，一款App的启动速度，不单单是用户体验的事情，往往还决定了它能否获取更多的用户。这就像第一次相亲见面，第">
<meta name="twitter:image" content="http://yoursite.com/2019/09/22/article-title/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-article-title" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/22/article-title/" class="article-date">
  <time datetime="2019-09-22T07:29:00.062Z" itemprop="datePublished">2019-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS启动优化与监控"><a href="#iOS启动优化与监控" class="headerlink" title="iOS启动优化与监控"></a><center>iOS启动优化与监控</center></h1><p>在开篇前，我们来模拟一个场景：假设你在买票结账的时候，掏出手机打开A支付App准备扫码支付，结果半天进不去，后面排队的人给你压力本身够大吧，然后，你又打开B支付App，秒进，支付完成后，试想一下，以后再次支付时，你会选择哪一个App呢。</p>
<p>不难想象，在功能与服务都类似的情况下，一款App的启动速度，不单单是用户体验的事情，往往还决定了它能否获取更多的用户。这就像第一次相亲见面，第一感觉往往决定了是否会继续交往</p>
<h2 id="App启动主要做了哪些操作"><a href="#App启动主要做了哪些操作" class="headerlink" title="App启动主要做了哪些操作"></a>App启动主要做了哪些操作</h2><p>一般情况下， App的启动分为冷启动和热启动。</p>
<ul>
<li>冷启动是指，App点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况，这是一次完整的启动过程。</li>
<li>热启动是指，App在冷启动后用户将App退后台，在App的进程还在系统里的情况下，用户重新启动进入App的过程，这个过程做的事情非常少。</li>
</ul>
<p>我们主要展开讲讲App冷启动的优化。</p>
<p>用户能感知到的启动慢，其实都发生在主线程上。而主线程慢的原因有很多，比如在主线程上执行大文件读写操作、在渲染周期中执行大量计算等。</p>
<blockquote>
<p>思考：为何所有的UI操作都必须发生在主线程，我可不可以开辟其他线程去处理呢？想详细了解的可以点击<a href="https://juejin.im/post/5c406d97e51d4552475fe178" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<p>那么，<strong>究竟如何才能把启动时的所有耗时都找出来呢？解决这个问题，你首先需要弄清楚App在启动时都干了哪些事儿。</strong></p>
<p>一般而言，App的启动时间，指的是从用户点击App开始，到用户看到第一个界面之间的时间。总的来说，App的启动主要包括三个阶段：</p>
<ol>
<li>main()函数执行前；</li>
<li>main()函数执行后；</li>
<li>首页渲染完成后。</li>
</ol>
<h3 id="main-函数执行前"><a href="#main-函数执行前" class="headerlink" title="main()函数执行前"></a>main()函数执行前</h3><p>在main()函数执行前，系统主要会做下面几件事情：</p>
<ul>
<li>解析Info.plist、加载相关信息，例如闪屏，沙箱建立、权限检查；</li>
<li>加载可执行文件（App的.o文件的集合）；</li>
<li>加载动态链接库，进行rebase指针调整和bind符号绑定；</li>
<li>Objc运行时的初始处理，包括Objc相关类的注册、category注册、selector唯一性检查等；</li>
<li>初始化，包括了执行+load()方法、attribute((constructor))修饰的函数的调用、创建C++静态全局变量。</li>
</ul>
<h4 id="术语概念解析"><a href="#术语概念解析" class="headerlink" title="术语概念解析"></a>术语概念解析</h4><h5 id="什么是dyld？"><a href="#什么是dyld？" class="headerlink" title="什么是dyld？"></a>什么是dyld？</h5><p>动态链接库的加载过程主要由dyld来完成，dyld是苹果的动态连接器。</p>
<p>系统先读取App的可执行文件（Mach-O文件），从里面获得dyld的路径，然后加载dyld，dyld去初始化运行环境，开启缓存策略，加载程序相关依赖库（其中也包含我们的可执行文件），并对这些库进行链接，最后调用每个依赖库的初始化方法，在这一步，runtime被初始化，当所有依赖库初始化后，然后调用所有的load方法。最后dyld返回main函数地址，main函数被调用，我们便来到了熟悉的程序入口。</p>
<p>当加载一个Mach-O文件（一个可执行文件或者一个库）时，动态链接器首先会检查共享缓存看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了OSX和iOS上程序的启动时间。</p>
<h5 id="什么是Mach-O镜像文件？"><a href="#什么是Mach-O镜像文件？" class="headerlink" title="什么是Mach-O镜像文件？"></a>什么是Mach-O镜像文件？</h5><p>Mach-O被划分成一些segment，每个segment又被划分成一些section。segment的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在arm64架构一页是16KB，其余为4KB。</p>
<p>section虽然没有整数倍页大小的限制，但是section之间不会有重叠。几乎所有Mach-O都包含这三个段（segment）：<code>__TEXT</code>，<code>__DATA</code>和<code>__LINKEDIT</code>。</p>
<p><code>__TEXT</code>包含Mach header，被执行的代码和只读常量（如C字符串）。只读可执行（r-x）。</p>
<p><code>__DATA</code>包含全局变量，静态变量等。可读写（rw-）。</p>
<p><code>__LINKEDIT</code>包含了加载程序的元数据，比如函数的名称和地址。只读（r-）。</p>
<p>ASLR（Address Space Layout Randomization）：地址空间布局随机化，镜像会在随机的地址上加载。</p>
<p>传统方式下，进程每次启动采用的都是固定可预见的方式，这意味着一个给定的程序在给定的架构上的进程初始虚拟内存都是基本一致的，而且在进程正常运行的生命周期中，内存中的地址分布具有非常强的可预测性，这给了黑客很大的施展空间（代码注入，重写内存）；</p>
<p>如果采用ASLR，进程每次启动，地址空间都会被简单地随机化，但是只是偏移，不是搅乱。大体布局–程序文本、数据和库是一样的，但是具体的地址都不同了，可以阻挡黑客对地址的猜测。</p>
<p>代码签名：可能我们认为Xcode会把整个文件都做加密hash并用做数字签名。其实为了在运行时验证Mach-O文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在__LINKEDIT中。这使得文件每页的内容都能及时被校验确并保不被篡改。</p>
<h5 id="虚拟内存？"><a href="#虚拟内存？" class="headerlink" title="虚拟内存？"></a>虚拟内存？</h5><p>我们开发者开发过程中所接触到的内存均为虚拟内存，虚拟内存使App认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是分布在多个物理内存碎片，系统的虚拟内存空间映射vm_map负责虚拟内存和物理内存的映射关系。</p>
<p>共享动态库其实就是共享的物理内存中的那份动态库，App虚拟内存中的共享动态库并未真实分配物理内存，使用时虚拟内存会访问同一份物理内存达到共享动态库的目的，当超过物理内存RAM的阈值后，系统会使用一部分硬盘空间ROM来充当内存使用，在需要时进行数据交换，当然磁盘的数据交换是远远慢于物理内存的，这也是我们内存过载时，App卡顿的原因之一。</p>
<h5 id="系统使用动态链接有几点好处："><a href="#系统使用动态链接有几点好处：" class="headerlink" title="系统使用动态链接有几点好处："></a>系统使用动态链接有几点好处：</h5><p>代码共用：很多程序都动态链接了这些lib，但它们在内存和磁盘中只有一份。</p>
<p>易于维护：由于被依赖的lib是程序执行时才链接的，所以这些lib很容易做更新，比如libSystem.dylib是libSystem.B.dylib的替身，哪天想升级直接换成libSystem.C.dylib，然后再替换替身就行了。</p>
<p>减少可执行文件体积：相比静态链接，动态链接在编译时不需要编译进去，所以可执行文件的体积要小很多。</p>
<p><img src="%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt="动态链接"></p>
<p>上图中，TEXT段两个进程共用，DATA段每个进程各一份。</p>
<p>下面开始详细分析<strong>pre-main</strong>的各个阶段</p>
<h4 id="加载Dylib"><a href="#加载Dylib" class="headerlink" title="加载Dylib"></a>加载Dylib</h4><p>从主执行文件的header获取到需要加载的所依赖的动态库列表，而header早就被内核映射过。然后它需要找到每个dylib，然后打开文件读取文件起始位置，确保它是Mach-O文件。接着会找到代码签名并将其注册到内核。然后在dylib文件的每个segment上调用mmap()。应用所依赖的dylib文件可能会再依赖其他dylib，所以dyld所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载100到400个dylib文件，但大部分都是系统dylib，它们会被预先计算和缓存起来，加载速度很快。</p>
<p>加载系统的dylib很快，因为有优化（操作系统自己要用部分framework，所以在操作系统开机后就已经加载到内存了）。但加载内嵌（embedded）的dylib文件很占时间，所以尽可能把多个内嵌dylib合并成一个来加载，或者使用static archive。</p>
<p>在每个动态库的加载过程中，dyld需要：</p>
<blockquote>
<p>1.分析所依赖的动态库 </p>
</blockquote>
<blockquote>
<p>2.找到动态库的Mach-O文件</p>
</blockquote>
<blockquote>
<p>3.打开文件</p>
</blockquote>
<blockquote>
<p>4.验证文件</p>
</blockquote>
<blockquote>
<p>5.在系统核心注册文件签名</p>
</blockquote>
<blockquote>
<p>6.对动态库的每一个segment调用mmap()</p>
</blockquote>
<p>针对这一步骤的优化有：</p>
<blockquote>
<p>1.减少非系统库的依赖</p>
</blockquote>
<blockquote>
<p>2.使用静态库而不是动态库</p>
</blockquote>
<blockquote>
<p>3.合并非动态库为一个动态库</p>
</blockquote>
<p>苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持6个非系统动态库合并为一个，多个动态库如何合并成一个动态库，可以参考这篇<a href="https://blog.automatic.com/how-we-cut-our-ios-apps-launch-time-in-half-with-this-one-cool-trick-7aca2011e2ea" target="_blank" rel="noopener">博客</a>，</p>
<h4 id="Rebase-amp-amp-Binding"><a href="#Rebase-amp-amp-Binding" class="headerlink" title="Rebase &amp;&amp; Binding"></a>Rebase &amp;&amp; Binding</h4><h5 id="Fix-ups"><a href="#Fix-ups" class="headerlink" title="Fix-ups"></a>Fix-ups</h5><p>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个dylib调用另一个dylib。这时需要很多间接层。</p>
<p>现代code-gen被叫做动态PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen实际上会在__DATA段中创建一个指向被调用者的指针，然后加载指针并跳转过去。</p>
<p>所以dyld做的事情就是修正（fix-up）指针和数据。Fix-up有两种类型，rebasing和binding。</p>
<h5 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h5><p>Rebasing: 在镜像内部调整指针的指向，针对mach-o在加载到内存中不是固定的首地址（ASLR）这一现象做数据修正的过程；</p>
<p>由于ASLR（address space layout randomization）的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。rebase修复的是指向当前镜像内部的资源指针；而bind指向的是镜像外部的资源指针。</p>
<p>在iOS4.3前会把dylib加载到指定地址，所有指针和数据对于代码来说都是固定的，dyld就无需做rebase/binding了。</p>
<p>iOS4.3后引入ASLR，dylib会被加载到随机地址，这个随机的地址跟代码和数据指向的旧地址会有偏差，dyld需要修正这个偏差，做法就是将dylib内部的指针地址都加上这个偏移量，偏移量的计算方法如下：</p>
<blockquote>
<p>Slide = actual_address - preferred_address</p>
</blockquote>
<p>然后就是重复不断地对<code>__DATA</code>段中须要rebase的指针加上这个偏移量。这就又涉及到page fault和COW。这可能会产生I/O瓶颈，但因为rebase的顺序是按地址排列的，所以从内核的角度来看，这是个有次序的任务，它会预先读入数据，减少I/O消耗。</p>
<p>在Rebasing和Binding前会判断是否已经Prebinding。如果已经进行过预绑定（Prebinding），那就不需要Rebasing和Binding这些Fix-up流程了，因为已经在预先绑定的地址加载好了。</p>
<p>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。</p>
<h5 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h5><p>Binding: 将指针指向镜像外部的内容，binding就是将这个二进制调用的外部符号进行绑定的过程。比如我们objc代码中需要使用到NSObject，即符号_OBJC_CLASS_$_NSObject，但是这个符号又不在我们的二进制中，在系统的Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</p>
<p>lazyBinding就是在加载动态库的时候不会立即binding，当第一次调用这个方法的时候再实施binding。做到的方法也很简单：通过dyld_stub_binder这个符号来做。lazyBinding的方法第一次会调用到dyld_stub_binder，然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用bind了。</p>
<p>Binding是处理那些指向dylib外部的指针，它们实际上被符号（symbol）名称绑定，也就是个字符串。<code>__LINKEDIT</code>段中也存储了需要bind的指针，以及指针需要指向的符号。dyld需要找到symbol对应的实现，这需要很多计算，去符号表里查找。找到后会将内容存储到<code>__DATA</code>段中的那个指针中。Binding看起来计算量比Rebasing更大，但其实需要的I/O操作很少，Binding的时间主要是耗费在计算上，因为IO操作之前Rebasing已经替Binding做过了，所以这两个步骤的耗时是混在一起的。</p>
<p>可以从查看<code>__DATA</code>段中须要修正（fix-up）的指针，所以减少指针数量才会减少这部分工作的耗时。对于ObjC来说就是减少Class，selector和category这些元数据的数量。从编码原则和设计模式之类的理论都会鼓励大家多写精致短小的类和方法，并将每部分方法独立出一个类别，其实这回增加启动时间。对于C++来说须要减少虚方法，因为虚方法回创建vtable，这也会在<code>__DATA</code>段中创建结构。虽然C++虚方法对启动耗时的增加要比ObjC元数据要少，但依然不可忽视。最后推荐使用Swift结构体，它需要fix-up的内容较少。</p>
<p>Objective-C中有很多数据结构都是靠Rebasing和Binding来修正（fix-up）的，比如Class中指向父类的指针和指向方法的指针。</p>
<p>Rebase&amp;&amp;Binding该阶段的优化关键在于减少<code>__DATA</code>segment中的指针数量，我们可以优化的点有：</p>
<blockquote>
<ol>
<li>减少Objc类数量，减少selector数量，把未使用的类和函数都可以删掉</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>减少C++虚函数数量</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>转而使用Swift struct</li>
</ol>
</blockquote>
<h4 id="Objc-SetUp"><a href="#Objc-SetUp" class="headerlink" title="Objc SetUp"></a>Objc SetUp</h4><p>主要做以下几件事来完成Objc Setup:</p>
<blockquote>
<ol>
<li>读取二进制文件的__DATA段内容，找到与objc相关的信息</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>注册Objc类，ObjC Runtime需要维护一张映射类名与类的全局表，当加载一个dylib时，其定义的所有类都需要被注册到这个全局表中</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>读取protocol以及category的信息，把category的定义插入方法列表（category registration）</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>确保selector的唯一性</li>
</ol>
</blockquote>
<p>ObjC是个动态语言，可以用类的名字来实例化一个类的对象。这意味着ObjC Runtime需要维护一张映射类名与类的全局表，当加载一个dylib时，其定义的所有的类都需要被注册到这个全局表中。</p>
<p>C++中有个问题叫做易碎的基类。ObjC就没有这个问题，因为会在加载时通过fix-up动态类中改变实例变量的偏移量。</p>
<p>在ObjC中可以通过定义类别（Category）的方式改变一个类的方法。有时你想要添加方法的类在另一个dylib中，而不在你的镜像中（也就是对系统或别人的类动刀），这时也需要做些fix-up。</p>
<p>ObjC中的selector必须是唯一的。</p>
<h4 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h4><p>以上三步属于静态调整，都是在修改__DATA segment中的内存，而这里则开始动态调整，开始在堆和栈中写入内容。工作主要有：</p>
<blockquote>
<ol>
<li>Objc的+load()函数</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>C++的构造函数属性函数，形如attribute((constructor)) void DoSomeInitializationWork()</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度</li>
</ol>
</blockquote>
<p>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库</p>
<blockquote>
<ol>
<li>dyld开始将程序二进制文件初始化</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>交由ImageLoader读取image，其中包含了我们的类、方法等各种符号</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>runtime接手后调用mapimages做解析和处理，接下来loadimages中调用 callloadmethods方法，遍历所有加载进来的Class，按继承层级依次调用Class的+load方法和其 Category的+load方法</li>
</ol>
</blockquote>
<p>整个事件由dyld主导，完成运行环境的初始化后，配合ImageLoader将二进制文件格式加载到内存，动态链接依赖库，并由runtime负责加载成objc定义的结构，所有初始化工作结束后，dyld调用真正的main函数，这一步可以做优化的地方有：</p>
<blockquote>
<ol>
<li>使用+initialize来替代+load</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>不要使用attribute((constructor))将方法显示标记为初始化器，而是让初始化方法调用时才执行</li>
</ol>
</blockquote>
<p>从效率上来说，在+load和+initialize里面执行同样的代码，效率是一样的，即使有差距，也不会差距太大。但所有的+load方法都在启动的时候调用，方法多了就会严重影响启动速度了，一个耗时大约4ms，100个就是400ms，这种耗时对于用户来说，是能明显感知的到的。而+initialize方法是在对应Class第一次使用的时候调用，这是一个懒加载的方法，不过当你把load中的逻辑移到initialize中的时候，一定要注意initialize的重复调用问题，能用dispatch_once()来完成的，就尽量不要到load方法。</p>
<p>如果程序刚刚被运行过，那么程序的代码会被dyld缓存，因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其它应用占据，那么这次启动所花费的时间就要长一点，这就分别是热启动和冷启动的概念。（具体dyld缓存的是动态库而不是APP的可执行代码，缓存的时间取决于内核是否会将其丢弃，跟操作系统的页面置换机制或内存清理机制有关）</p>
<h3 id="main-函数执行后"><a href="#main-函数执行后" class="headerlink" title="main()函数执行后"></a>main()函数执行后</h3><p>main()函数执行后的阶段，指的是从main()函数执行开始，到appDelegate的didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。</p>
<p>首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括了：</p>
<ul>
<li>首屏初始化所需配置文件的读写操作</li>
<li>首屏列表大数据的读取</li>
<li>首屏渲染的大量计算</li>
</ul>
<p>很多时候，开发者会把各种初始化工作都放到这个阶段执行，导致渲染完成滞后。<strong>更加优化的开发方式，应该是</strong>从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是App启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的。梳理完之后，将这些初始化功能分别放到合适的阶段进行。</p>
<h4 id="首屏渲染完成后"><a href="#首屏渲染完成后" class="headerlink" title="首屏渲染完成后:"></a>首屏渲染完成后:</h4><p>首屏渲染后的这个阶段，指的是didFinishLaunchWithOptions方法作用域内执行首屏渲染之后的所有方法执行完成，即从设置了self.window.rootViewController开始到didFinishLaunchWithOptions方法作用域结束。</p>
<p>首屏渲染完成后用户就可以看到App的首页信息了，把这个阶段内卡住主线程的方法解决掉就可以了。</p>
<h4 id="功能级别的启动优化"><a href="#功能级别的启动优化" class="headerlink" title="功能级别的启动优化"></a>功能级别的启动优化</h4><p>功能级别的启动优化，就是要从main()函数执行后这个阶段下手。</p>
<p>优化的思路是：main()函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。</p>
<h4 id="方法级别的启动优化"><a href="#方法级别的启动优化" class="headerlink" title="方法级别的启动优化"></a>方法级别的启动优化</h4><p>方法级别的启动优化主要是检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。</p>
<p>除了优化资源的操作，我们还可以通过一些监控手段来监控App的启动速度，主要有两种手段：</p>
<p><strong>第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时</strong>。Xcode工具套件里自带的Time Profile，采用的就是这种方式。</p>
<p>这种方式的优点是，开发类似工具成本不高，能够快速开发后集成到你的App中，以便在真实环境中进行检查。</p>
<p>说到定时抓取，就会涉及到定时间隔的长短问题。</p>
<ul>
<li>定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确</li>
<li>定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确</li>
</ul>
<p>这个定时间隔如果小于所有方法执行的时间（比如0.002秒），那么基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为0.01秒。这样设置，对整体耗时的影响小，不过很多方法耗时就不精确了。但因为整体耗时的数据更加重要些，单个方法耗时精度不高也是可以接受的，所以这个设置也是没问题的。</p>
<p>总结来说，定时抓取主线程调用栈的方式虽然精准度不够高，但也是够用的。</p>
<p><strong>第二种方法是，对objc_msgSend方法进行hook来掌握所有方法的执行耗时</strong>。</p>
<h4 id="Xcode提供的查看耗时方法"><a href="#Xcode提供的查看耗时方法" class="headerlink" title="Xcode提供的查看耗时方法"></a>Xcode提供的查看耗时方法</h4><h5 id="查看Main-调用前花费的总时间"><a href="#查看Main-调用前花费的总时间" class="headerlink" title="查看Main()调用前花费的总时间"></a>查看Main()调用前花费的总时间</h5><p>在<strong>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Arguments-&gt;Environment Variables-&gt;<code>DYLD_PRINT_STATISTICS</code></strong>设置为YES，就可以在控制台查看main函数执行前总共花费多长时间。</p>
<p><img src="%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="设置环境变量"></p>
<p><img src="%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BApre-main%E7%9A%84%E6%80%BB%E6%97%B6%E9%97%B4.jpg" alt="控制台输出pre-main的总时间"></p>
<h5 id="查看加载了多少动态库"><a href="#查看加载了多少动态库" class="headerlink" title="查看加载了多少动态库"></a>查看加载了多少动态库</h5><p>在<strong>Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Diagnostics-&gt;Logging-&gt;勾选Dynamic Library Loads</strong>，就可以在控制台中查看本项目中加载的所有动态库（包括系统的和自己的）</p>
<p><img src="%E5%8A%A8%E6%80%81%E5%BA%93%E8%AE%BE%E7%BD%AE.jpg" alt="动态库设置"></p>
<p><img src="%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%8A%A8%E6%80%81%E5%BA%93.jpg" alt="控制台打印动态库"></p>
<h5 id="查看Main函数启动后的耗时"><a href="#查看Main函数启动后的耗时" class="headerlink" title="查看Main函数启动后的耗时"></a>查看Main函数启动后的耗时</h5><p>main函数调用后的耗时，可以使用一些工具来监控，有一种非常笨但是很实用的方法，就是通过打点，在didFinishLaunchingWithOptions开始前打一个点，在App显示完成后第一个界面再打一个点，计算两个点之间的耗时，就可以知道main函数调用后到界面显示出来的耗时了，但是这样只能笼统的知道总的耗时，并不能准确的知道时间花在哪里。</p>
<p>如果想用这个打点法的话，推荐一个打点工具<a href="https://github.com/beiliao-mobile/BLStopwatch" target="_blank" rel="noopener">BLStopwatch</a></p>
<p>如果想准确知道时间都花在哪里，推荐使用下面两种方式</p>
<h2 id="APP具体优化"><a href="#APP具体优化" class="headerlink" title="APP具体优化"></a>APP具体优化</h2><p>++</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/22/article-title/" data-id="ck0unxdgo000019y49g6d0gr5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/09/22/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/22/article-title/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/22/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>